 
////////////////////////////////////////////////////////////////////
//                         AUTO-GENERATED                         //
////////////////////////////////////////////////////////////////////
//                                                                //
// This file was generated by a tool. Do not modify it directly.  //
// Instead, modify the source file ProAbonoClientRequests.cs.     //
//                                                                //
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace ProAbono
{
    public interface IProAbonoClient
    {
        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceSegment">the related segment (only used to localize the texts in the default language if 'language' hasn't been provided)</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature</returns>
        Feature RetrieveFeature(string referenceFeature, string referenceSegment = null, string language = null, bool? html = true);

        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature, with its current usage (aggregated among the user's subscriptions)</returns>
        Feature RetrieveFeatureForCustomer(string referenceFeature, string referenceCustomer, string language = null, bool? html = true);

        /// <summary>
        /// Retrieve a list of features
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features</returns>
        PaginatedList<Feature> RetrieveFeatures(string referenceSegment = null, bool? isVisible = null, string language = null, bool? html = true, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve the list of features available to a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features, with the current usage of each feature (aggregated among the user's subscriptions)</returns>
        PaginatedList<Feature> RetrieveFeaturesForCustomer(string referenceCustomer, bool? isVisible = null, bool? html = true, int? page = null, int? sizePage = null);

        /// <summary>
        /// Insert or update a customer
        /// </summary>
        /// <param name="referenceCustomer">new or existing customer reference</param>
        /// <param name="customerInfo">the customer properties</param>
        /// <param name="referenceSegment">the segment you want the push the customer into. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <returns>The inserted/updated customer</returns>
        Customer SaveCustomer(string referenceCustomer, CustomerInfo customerInfo, string referenceSegment = null);

        /// <summary>
        /// Retrieve a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of requested customer</param>
        /// <returns>the related customer</returns>
        Customer RetrieveCustomer(string referenceCustomer);

        /// <summary>
        /// Retrieve a list of customers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers</returns>
        PaginatedList<Customer> ListCustomers(string referenceSegment = null, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve a list of customers having access to a given feature
        /// </summary>
        /// <param name="referenceFeature">specifies the feature the customers must have access to</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers, with their current usage of the feature</returns>
        PaginatedList<CustomerWithUsage> ListCustomersByFeature(string referenceFeature, string referenceSegment, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        Address RetrieveBillingAddress(string referenceCustomer);

        /// <summary>
        /// Insert or update the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="billingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        Address SaveBillingAddress(string referenceCustomer, Address billingAddress);

        /// <summary>
        /// Retrieve the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        Address RetrieveShippingAddress(string referenceCustomer);

        /// <summary>
        /// Insert or update the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="shippingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        Address SaveShippingAddress(string referenceCustomer, Address shippingAddress);

        /// <summary>
        /// Retrieve the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The settings, or null if not found</returns>
        PaymentSettings RetrievePaymentSettings(string referenceCustomer);

        /// <summary>
        /// Insert or update the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="settings">the new settings</param>
        /// <returns>The inserted/updated settings</returns>
        PaymentSettings SavePaymentSettings(string referenceCustomer, PaymentSettings settings);

        /// <summary>
        /// Get a list of usages for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceFeature">filter - get only usages for that feature</param>
        /// <param name="aggregate">true to aggregate all usages of the same feature</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        PaginatedList<Usage> RetrieveUsagesForCustomer(string referenceCustomer, string referenceFeature = null, bool aggregate = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get a list of usages for a given subscription
        /// </summary>
        /// <param name="idSubscription">id of the subscription</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        PaginatedList<Usage> RetrieveUsagesForSubscription(long idSubscription, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get a list of usages for a given feature
        /// </summary>
        /// <param name="referenceFeature">reference of the feature</param>
        /// <param name="aggregate">true to aggregate all usages of that feature for the same customer</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        PaginatedList<Usage> RetrieveUsagesForFeature(string referenceFeature, bool aggregate = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get usage for a given customer and feature.
        /// If the given feature is present in multiple subscriptions for the customer, then the usages are aggregated.
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        Usage RetrieveUsageForCustomer(string referenceCustomer, string referenceFeature);

        /// <summary>
        /// Get usage for a given subscription and feature
        /// </summary>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        Usage RetrieveUsageForSubscription(long idSubscription, string referenceFeature);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="increment">the increment to apply to current usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Usage UpdateUsageByIncrement(string referenceCustomer, string referenceFeature, int increment, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="quantityCurrent">the new usage quantity</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Usage UpdateUsageByCurrentQuantity(string referenceCustomer, string referenceFeature, int quantityCurrent, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="isEnabled">toggle usage on an on/off feature</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Usage UpdateUsageByActivation(string referenceCustomer, string referenceFeature, bool isEnabled, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="increment">the number of units to increment that usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Pricing EstimateUsageUpdateByIncrement(string referenceCustomer, string referenceFeature, int increment, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="quantityCurrent">the new value of the usage (On-Off features only)</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Pricing EstimateUsageUpdateByCurrentQuantity(string referenceCustomer, string referenceFeature, int quantityCurrent, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="isEnabled">the new status of given on-off usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Pricing EstimateUsageUpdateByActivation(string referenceCustomer, string referenceFeature, bool isEnabled, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Compute the exact price for given customer to subscribe to given offer
        /// If there is a trial, the pricing will contain the pricing for the first billing period and the pricing for the next term
        /// You can override the offer's parameters in case you need a customized subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Pricing EstimateSubscriptionUpgrade(string referenceCustomer, string referenceOffer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, bool? html = true);

        /// <summary>
        /// Retrieve an offer
        /// </summary>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <returns>The related offer</returns>
        Offer RetrieveOffer(string referenceOffer, string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? links = false);

        /// <summary>
        /// Retrieve an offer for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - ignored if ignoreFeatures has been specified. If true, returns only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related offer, with customer-specific 'subscribe' links to allow the customer to subscribe to the offer</returns>
        Offer RetrieveOfferForCustomer(string referenceCustomer, string referenceOffer, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null);

        /// <summary>
        /// Retrieve a list of offers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers</returns>
        PaginatedList<Offer> RetrieveOffers(string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null, bool? links = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve a list of offers for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'subscribe' links to allow the customer to subscribe to each offer</returns>
        PaginatedList<Offer> RetrieveOffersForCustomer(string referenceCustomer, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve an offer to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <returns>The related offer, with customer-specific 'upgrade' links to allow the customer to subscribe to the offer</returns>
        Offer RetrieveOfferToUpgradeCustomer(string referenceCustomer, string referenceOffer, long? idSubscription = null, bool? html = true, bool? ignoreFeatures = false);

        /// <summary>
        /// Retrieve a list of offers to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'upgrade' links to allow the customer to subscribe to each offer</returns>
        PaginatedList<Offer> RetrieveOffersToUpgradeCustomer(string referenceCustomer, long? idSubscription = null, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Create (and start) a subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">(mandatory) reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="titleLocalized">Offer override - localized title</param>
        /// <param name="descriptionLocalized">Offer override - localized description</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription CreateSubscription(string referenceOffer, string referenceCustomer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, string titleLocalized = null, string descriptionLocalized = null, bool? html = null);

        /// <summary>
        /// Retrieve a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription RetrieveSubscription(long idSubscription, bool? html = null);

        /// <summary>
        /// Retrieve a running subscription for a customer.
        ///
        /// Throws an error if the customer has multiple running subscriptions.
        /// </summary>
        /// <param name="referenceCustomer">Customer whose subscription is requested. </param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription RetrieveSubscriptionForCustomer(string referenceCustomer, bool? html = null);

        /// <summary>
        /// Suspend a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="subscriptionState">The subscription suspension status.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription SuspendSubscription(long idSubscription, SubscriptionState subscriptionState = SubscriptionState.SuspendedAgent, bool? html = null);

        /// <summary>
        /// Start or restart a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription StartSubscription(long idSubscription, bool? html = null);

        /// <summary>
        /// Terminate a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="immediate">true to terminate the subscription immediately, false to terminate at the end of the billign period.</param>
        /// <param name="dateTermination">ignored if immediate is true. Date of termination, if you need to specify a date that is not the end of the billing period.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription TerminateSubscription(long idSubscription, bool immediate = false, DateTime? dateTermination = null, bool? html = null);

        /// <summary>
        /// Upgrade a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="referenceOffer">reference of the related offer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription UpgradeSubscription(long idSubscription, string referenceOffer, bool? html = null);

        /// <summary>
        /// Change the renewal date of a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="dateRenewal">the updated renewal date. Must be in the future</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        DetailedSubscription UpdateSubscriptionRenewalDate(long idSubscription, DateTime dateRenewal, bool? html = null);

        /// <summary>
        /// Retrieve a list of subscriptions
        /// </summary>
        /// <param name="referenceCustomer">Filter - returns only subscription where given customer is the recipient</param>
        /// <param name="referenceCustomerBuyer">Filter - returns only subscription where given customer is the buyer</param>
        /// <param name="referenceSegment">the related segment, if not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The list of subscriptions</returns>
        PaginatedList<Subscription> ListSubscriptions(string referenceCustomer = null, string referenceCustomerBuyer = null, string referenceSegment = null, bool? html = null, int? page = null, int? sizePage = null);

 
    }

    public interface IAsyncProAbonoClient
    {
        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceSegment">the related segment (only used to localize the texts in the default language if 'language' hasn't been provided)</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature</returns>
        Task<Feature> RetrieveFeatureAsync(string referenceFeature, string referenceSegment = null, string language = null, bool? html = true);

        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature, with its current usage (aggregated among the user's subscriptions)</returns>
        Task<Feature> RetrieveFeatureForCustomerAsync(string referenceFeature, string referenceCustomer, string language = null, bool? html = true);

        /// <summary>
        /// Retrieve a list of features
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features</returns>
        Task<PaginatedList<Feature>> RetrieveFeaturesAsync(string referenceSegment = null, bool? isVisible = null, string language = null, bool? html = true, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve the list of features available to a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features, with the current usage of each feature (aggregated among the user's subscriptions)</returns>
        Task<PaginatedList<Feature>> RetrieveFeaturesForCustomerAsync(string referenceCustomer, bool? isVisible = null, bool? html = true, int? page = null, int? sizePage = null);

        /// <summary>
        /// Insert or update a customer
        /// </summary>
        /// <param name="referenceCustomer">new or existing customer reference</param>
        /// <param name="customerInfo">the customer properties</param>
        /// <param name="referenceSegment">the segment you want the push the customer into. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <returns>The inserted/updated customer</returns>
        Task<Customer> SaveCustomerAsync(string referenceCustomer, CustomerInfo customerInfo, string referenceSegment = null);

        /// <summary>
        /// Retrieve a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of requested customer</param>
        /// <returns>the related customer</returns>
        Task<Customer> RetrieveCustomerAsync(string referenceCustomer);

        /// <summary>
        /// Retrieve a list of customers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers</returns>
        Task<PaginatedList<Customer>> ListCustomersAsync(string referenceSegment = null, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve a list of customers having access to a given feature
        /// </summary>
        /// <param name="referenceFeature">specifies the feature the customers must have access to</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers, with their current usage of the feature</returns>
        Task<PaginatedList<CustomerWithUsage>> ListCustomersByFeatureAsync(string referenceFeature, string referenceSegment, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        Task<Address> RetrieveBillingAddressAsync(string referenceCustomer);

        /// <summary>
        /// Insert or update the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="billingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        Task<Address> SaveBillingAddressAsync(string referenceCustomer, Address billingAddress);

        /// <summary>
        /// Retrieve the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        Task<Address> RetrieveShippingAddressAsync(string referenceCustomer);

        /// <summary>
        /// Insert or update the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="shippingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        Task<Address> SaveShippingAddressAsync(string referenceCustomer, Address shippingAddress);

        /// <summary>
        /// Retrieve the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The settings, or null if not found</returns>
        Task<PaymentSettings> RetrievePaymentSettingsAsync(string referenceCustomer);

        /// <summary>
        /// Insert or update the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="settings">the new settings</param>
        /// <returns>The inserted/updated settings</returns>
        Task<PaymentSettings> SavePaymentSettingsAsync(string referenceCustomer, PaymentSettings settings);

        /// <summary>
        /// Get a list of usages for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceFeature">filter - get only usages for that feature</param>
        /// <param name="aggregate">true to aggregate all usages of the same feature</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        Task<PaginatedList<Usage>> RetrieveUsagesForCustomerAsync(string referenceCustomer, string referenceFeature = null, bool aggregate = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get a list of usages for a given subscription
        /// </summary>
        /// <param name="idSubscription">id of the subscription</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        Task<PaginatedList<Usage>> RetrieveUsagesForSubscriptionAsync(long idSubscription, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get a list of usages for a given feature
        /// </summary>
        /// <param name="referenceFeature">reference of the feature</param>
        /// <param name="aggregate">true to aggregate all usages of that feature for the same customer</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        Task<PaginatedList<Usage>> RetrieveUsagesForFeatureAsync(string referenceFeature, bool aggregate = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Get usage for a given customer and feature.
        /// If the given feature is present in multiple subscriptions for the customer, then the usages are aggregated.
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        Task<Usage> RetrieveUsageForCustomerAsync(string referenceCustomer, string referenceFeature);

        /// <summary>
        /// Get usage for a given subscription and feature
        /// </summary>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        Task<Usage> RetrieveUsageForSubscriptionAsync(long idSubscription, string referenceFeature);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="increment">the increment to apply to current usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Task<Usage> UpdateUsageByIncrementAsync(string referenceCustomer, string referenceFeature, int increment, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="quantityCurrent">the new usage quantity</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Task<Usage> UpdateUsageByCurrentQuantityAsync(string referenceCustomer, string referenceFeature, int quantityCurrent, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="isEnabled">toggle usage on an on/off feature</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        Task<Usage> UpdateUsageByActivationAsync(string referenceCustomer, string referenceFeature, bool isEnabled, DateTime? dateStamp = null, long? idSubscription = null);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="increment">the number of units to increment that usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Task<Pricing> EstimateUsageUpdateByIncrementAsync(string referenceCustomer, string referenceFeature, int increment, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="quantityCurrent">the new value of the usage (On-Off features only)</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Task<Pricing> EstimateUsageUpdateByCurrentQuantityAsync(string referenceCustomer, string referenceFeature, int quantityCurrent, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="isEnabled">the new status of given on-off usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Task<Pricing> EstimateUsageUpdateByActivationAsync(string referenceCustomer, string referenceFeature, bool isEnabled, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true);

        /// <summary>
        /// Compute the exact price for given customer to subscribe to given offer
        /// If there is a trial, the pricing will contain the pricing for the first billing period and the pricing for the next term
        /// You can override the offer's parameters in case you need a customized subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        Task<Pricing> EstimateSubscriptionUpgradeAsync(string referenceCustomer, string referenceOffer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, bool? html = true);

        /// <summary>
        /// Retrieve an offer
        /// </summary>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <returns>The related offer</returns>
        Task<Offer> RetrieveOfferAsync(string referenceOffer, string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? links = false);

        /// <summary>
        /// Retrieve an offer for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - ignored if ignoreFeatures has been specified. If true, returns only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related offer, with customer-specific 'subscribe' links to allow the customer to subscribe to the offer</returns>
        Task<Offer> RetrieveOfferForCustomerAsync(string referenceCustomer, string referenceOffer, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null);

        /// <summary>
        /// Retrieve a list of offers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers</returns>
        Task<PaginatedList<Offer>> RetrieveOffersAsync(string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null, bool? links = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve a list of offers for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'subscribe' links to allow the customer to subscribe to each offer</returns>
        Task<PaginatedList<Offer>> RetrieveOffersForCustomerAsync(string referenceCustomer, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Retrieve an offer to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <returns>The related offer, with customer-specific 'upgrade' links to allow the customer to subscribe to the offer</returns>
        Task<Offer> RetrieveOfferToUpgradeCustomerAsync(string referenceCustomer, string referenceOffer, long? idSubscription = null, bool? html = true, bool? ignoreFeatures = false);

        /// <summary>
        /// Retrieve a list of offers to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'upgrade' links to allow the customer to subscribe to each offer</returns>
        Task<PaginatedList<Offer>> RetrieveOffersToUpgradeCustomerAsync(string referenceCustomer, long? idSubscription = null, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null);

        /// <summary>
        /// Create (and start) a subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">(mandatory) reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="titleLocalized">Offer override - localized title</param>
        /// <param name="descriptionLocalized">Offer override - localized description</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> CreateSubscriptionAsync(string referenceOffer, string referenceCustomer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, string titleLocalized = null, string descriptionLocalized = null, bool? html = null);

        /// <summary>
        /// Retrieve a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> RetrieveSubscriptionAsync(long idSubscription, bool? html = null);

        /// <summary>
        /// Retrieve a running subscription for a customer.
        ///
        /// Throws an error if the customer has multiple running subscriptions.
        /// </summary>
        /// <param name="referenceCustomer">Customer whose subscription is requested. </param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> RetrieveSubscriptionForCustomerAsync(string referenceCustomer, bool? html = null);

        /// <summary>
        /// Suspend a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="subscriptionState">The subscription suspension status.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> SuspendSubscriptionAsync(long idSubscription, SubscriptionState subscriptionState = SubscriptionState.SuspendedAgent, bool? html = null);

        /// <summary>
        /// Start or restart a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> StartSubscriptionAsync(long idSubscription, bool? html = null);

        /// <summary>
        /// Terminate a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="immediate">true to terminate the subscription immediately, false to terminate at the end of the billign period.</param>
        /// <param name="dateTermination">ignored if immediate is true. Date of termination, if you need to specify a date that is not the end of the billing period.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> TerminateSubscriptionAsync(long idSubscription, bool immediate = false, DateTime? dateTermination = null, bool? html = null);

        /// <summary>
        /// Upgrade a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="referenceOffer">reference of the related offer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> UpgradeSubscriptionAsync(long idSubscription, string referenceOffer, bool? html = null);

        /// <summary>
        /// Change the renewal date of a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="dateRenewal">the updated renewal date. Must be in the future</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        Task<DetailedSubscription> UpdateSubscriptionRenewalDateAsync(long idSubscription, DateTime dateRenewal, bool? html = null);

        /// <summary>
        /// Retrieve a list of subscriptions
        /// </summary>
        /// <param name="referenceCustomer">Filter - returns only subscription where given customer is the recipient</param>
        /// <param name="referenceCustomerBuyer">Filter - returns only subscription where given customer is the buyer</param>
        /// <param name="referenceSegment">the related segment, if not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The list of subscriptions</returns>
        Task<PaginatedList<Subscription>> ListSubscriptionsAsync(string referenceCustomer = null, string referenceCustomerBuyer = null, string referenceSegment = null, bool? html = null, int? page = null, int? sizePage = null);

 
    }

    public partial class ProAbonoClient : IProAbonoClient, IAsyncProAbonoClient
    {
        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceSegment">the related segment (only used to localize the texts in the default language if 'language' hasn't been provided)</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature</returns>
        public Feature RetrieveFeature(string referenceFeature, string referenceSegment = null, string language = null, bool? html = true)
        {
            return this.RetrieveFeatureRequest(referenceFeature, referenceSegment, language, html).Execute();
        }

        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceSegment">the related segment (only used to localize the texts in the default language if 'language' hasn't been provided)</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature</returns>
        public Task<Feature> RetrieveFeatureAsync(string referenceFeature, string referenceSegment = null, string language = null, bool? html = true)
        {
            return this.RetrieveFeatureRequest(referenceFeature, referenceSegment, language, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature, with its current usage (aggregated among the user's subscriptions)</returns>
        public Feature RetrieveFeatureForCustomer(string referenceFeature, string referenceCustomer, string language = null, bool? html = true)
        {
            return this.RetrieveFeatureForCustomerRequest(referenceFeature, referenceCustomer, language, html).Execute();
        }

        /// <summary>
        /// Retrieve a feature
        /// </summary>
        /// <param name="referenceFeature">reference of requested feature</param>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related feature, with its current usage (aggregated among the user's subscriptions)</returns>
        public Task<Feature> RetrieveFeatureForCustomerAsync(string referenceFeature, string referenceCustomer, string language = null, bool? html = true)
        {
            return this.RetrieveFeatureForCustomerRequest(referenceFeature, referenceCustomer, language, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of features
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features</returns>
        public PaginatedList<Feature> RetrieveFeatures(string referenceSegment = null, bool? isVisible = null, string language = null, bool? html = true, int? page = null, int? sizePage = null)
        {
            return this.RetrieveFeaturesRequest(referenceSegment, isVisible, language, html, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of features
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features</returns>
        public Task<PaginatedList<Feature>> RetrieveFeaturesAsync(string referenceSegment = null, bool? isVisible = null, string language = null, bool? html = true, int? page = null, int? sizePage = null)
        {
            return this.RetrieveFeaturesRequest(referenceSegment, isVisible, language, html, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve the list of features available to a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features, with the current usage of each feature (aggregated among the user's subscriptions)</returns>
        public PaginatedList<Feature> RetrieveFeaturesForCustomer(string referenceCustomer, bool? isVisible = null, bool? html = true, int? page = null, int? sizePage = null)
        {
            return this.RetrieveFeaturesForCustomerRequest(referenceCustomer, isVisible, html, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve the list of features available to a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="isVisible">filter - get only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related features, with the current usage of each feature (aggregated among the user's subscriptions)</returns>
        public Task<PaginatedList<Feature>> RetrieveFeaturesForCustomerAsync(string referenceCustomer, bool? isVisible = null, bool? html = true, int? page = null, int? sizePage = null)
        {
            return this.RetrieveFeaturesForCustomerRequest(referenceCustomer, isVisible, html, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Insert or update a customer
        /// </summary>
        /// <param name="referenceCustomer">new or existing customer reference</param>
        /// <param name="customerInfo">the customer properties</param>
        /// <param name="referenceSegment">the segment you want the push the customer into. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <returns>The inserted/updated customer</returns>
        public Customer SaveCustomer(string referenceCustomer, CustomerInfo customerInfo, string referenceSegment = null)
        {
            return this.SaveCustomerRequest(referenceCustomer, customerInfo, referenceSegment).Execute();
        }

        /// <summary>
        /// Insert or update a customer
        /// </summary>
        /// <param name="referenceCustomer">new or existing customer reference</param>
        /// <param name="customerInfo">the customer properties</param>
        /// <param name="referenceSegment">the segment you want the push the customer into. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <returns>The inserted/updated customer</returns>
        public Task<Customer> SaveCustomerAsync(string referenceCustomer, CustomerInfo customerInfo, string referenceSegment = null)
        {
            return this.SaveCustomerRequest(referenceCustomer, customerInfo, referenceSegment).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of requested customer</param>
        /// <returns>the related customer</returns>
        public Customer RetrieveCustomer(string referenceCustomer)
        {
            return this.RetrieveCustomerRequest(referenceCustomer).Execute();
        }

        /// <summary>
        /// Retrieve a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of requested customer</param>
        /// <returns>the related customer</returns>
        public Task<Customer> RetrieveCustomerAsync(string referenceCustomer)
        {
            return this.RetrieveCustomerRequest(referenceCustomer).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of customers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers</returns>
        public PaginatedList<Customer> ListCustomers(string referenceSegment = null, int? page = null, int? sizePage = null)
        {
            return this.ListCustomersRequest(referenceSegment, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of customers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers</returns>
        public Task<PaginatedList<Customer>> ListCustomersAsync(string referenceSegment = null, int? page = null, int? sizePage = null)
        {
            return this.ListCustomersRequest(referenceSegment, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of customers having access to a given feature
        /// </summary>
        /// <param name="referenceFeature">specifies the feature the customers must have access to</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers, with their current usage of the feature</returns>
        public PaginatedList<CustomerWithUsage> ListCustomersByFeature(string referenceFeature, string referenceSegment, int? page = null, int? sizePage = null)
        {
            return this.ListCustomersByFeatureRequest(referenceFeature, referenceSegment, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of customers having access to a given feature
        /// </summary>
        /// <param name="referenceFeature">specifies the feature the customers must have access to</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>the list of customers, with their current usage of the feature</returns>
        public Task<PaginatedList<CustomerWithUsage>> ListCustomersByFeatureAsync(string referenceFeature, string referenceSegment, int? page = null, int? sizePage = null)
        {
            return this.ListCustomersByFeatureRequest(referenceFeature, referenceSegment, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        public Address RetrieveBillingAddress(string referenceCustomer)
        {
            return this.RetrieveBillingAddressRequest(referenceCustomer).Execute();
        }

        /// <summary>
        /// Retrieve the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        public Task<Address> RetrieveBillingAddressAsync(string referenceCustomer)
        {
            return this.RetrieveBillingAddressRequest(referenceCustomer).ExecuteAsync();
        }

        /// <summary>
        /// Insert or update the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="billingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        public Address SaveBillingAddress(string referenceCustomer, Address billingAddress)
        {
            return this.SaveBillingAddressRequest(referenceCustomer, billingAddress).Execute();
        }

        /// <summary>
        /// Insert or update the billing address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="billingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        public Task<Address> SaveBillingAddressAsync(string referenceCustomer, Address billingAddress)
        {
            return this.SaveBillingAddressRequest(referenceCustomer, billingAddress).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        public Address RetrieveShippingAddress(string referenceCustomer)
        {
            return this.RetrieveShippingAddressRequest(referenceCustomer).Execute();
        }

        /// <summary>
        /// Retrieve the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The address, or null if not found</returns>
        public Task<Address> RetrieveShippingAddressAsync(string referenceCustomer)
        {
            return this.RetrieveShippingAddressRequest(referenceCustomer).ExecuteAsync();
        }

        /// <summary>
        /// Insert or update the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="shippingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        public Address SaveShippingAddress(string referenceCustomer, Address shippingAddress)
        {
            return this.SaveShippingAddressRequest(referenceCustomer, shippingAddress).Execute();
        }

        /// <summary>
        /// Insert or update the shipping address of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="shippingAddress">the new address</param>
        /// <returns>The inserted/updated address</returns>
        public Task<Address> SaveShippingAddressAsync(string referenceCustomer, Address shippingAddress)
        {
            return this.SaveShippingAddressRequest(referenceCustomer, shippingAddress).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The settings, or null if not found</returns>
        public PaymentSettings RetrievePaymentSettings(string referenceCustomer)
        {
            return this.RetrievePaymentSettingsRequest(referenceCustomer).Execute();
        }

        /// <summary>
        /// Retrieve the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <returns>The settings, or null if not found</returns>
        public Task<PaymentSettings> RetrievePaymentSettingsAsync(string referenceCustomer)
        {
            return this.RetrievePaymentSettingsRequest(referenceCustomer).ExecuteAsync();
        }

        /// <summary>
        /// Insert or update the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="settings">the new settings</param>
        /// <returns>The inserted/updated settings</returns>
        public PaymentSettings SavePaymentSettings(string referenceCustomer, PaymentSettings settings)
        {
            return this.SavePaymentSettingsRequest(referenceCustomer, settings).Execute();
        }

        /// <summary>
        /// Insert or update the payment settings of a customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="settings">the new settings</param>
        /// <returns>The inserted/updated settings</returns>
        public Task<PaymentSettings> SavePaymentSettingsAsync(string referenceCustomer, PaymentSettings settings)
        {
            return this.SavePaymentSettingsRequest(referenceCustomer, settings).ExecuteAsync();
        }

        /// <summary>
        /// Get a list of usages for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceFeature">filter - get only usages for that feature</param>
        /// <param name="aggregate">true to aggregate all usages of the same feature</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public PaginatedList<Usage> RetrieveUsagesForCustomer(string referenceCustomer, string referenceFeature = null, bool aggregate = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForCustomerRequest(referenceCustomer, referenceFeature, aggregate, page, sizePage).Execute();
        }

        /// <summary>
        /// Get a list of usages for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceFeature">filter - get only usages for that feature</param>
        /// <param name="aggregate">true to aggregate all usages of the same feature</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public Task<PaginatedList<Usage>> RetrieveUsagesForCustomerAsync(string referenceCustomer, string referenceFeature = null, bool aggregate = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForCustomerRequest(referenceCustomer, referenceFeature, aggregate, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Get a list of usages for a given subscription
        /// </summary>
        /// <param name="idSubscription">id of the subscription</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public PaginatedList<Usage> RetrieveUsagesForSubscription(long idSubscription, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForSubscriptionRequest(idSubscription, page, sizePage).Execute();
        }

        /// <summary>
        /// Get a list of usages for a given subscription
        /// </summary>
        /// <param name="idSubscription">id of the subscription</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public Task<PaginatedList<Usage>> RetrieveUsagesForSubscriptionAsync(long idSubscription, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForSubscriptionRequest(idSubscription, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Get a list of usages for a given feature
        /// </summary>
        /// <param name="referenceFeature">reference of the feature</param>
        /// <param name="aggregate">true to aggregate all usages of that feature for the same customer</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public PaginatedList<Usage> RetrieveUsagesForFeature(string referenceFeature, bool aggregate = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForFeatureRequest(referenceFeature, aggregate, page, sizePage).Execute();
        }

        /// <summary>
        /// Get a list of usages for a given feature
        /// </summary>
        /// <param name="referenceFeature">reference of the feature</param>
        /// <param name="aggregate">true to aggregate all usages of that feature for the same customer</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related usages</returns>
        public Task<PaginatedList<Usage>> RetrieveUsagesForFeatureAsync(string referenceFeature, bool aggregate = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveUsagesForFeatureRequest(referenceFeature, aggregate, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Get usage for a given customer and feature.
        /// If the given feature is present in multiple subscriptions for the customer, then the usages are aggregated.
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        public Usage RetrieveUsageForCustomer(string referenceCustomer, string referenceFeature)
        {
            return this.RetrieveUsageForCustomerRequest(referenceCustomer, referenceFeature).Execute();
        }

        /// <summary>
        /// Get usage for a given customer and feature.
        /// If the given feature is present in multiple subscriptions for the customer, then the usages are aggregated.
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        public Task<Usage> RetrieveUsageForCustomerAsync(string referenceCustomer, string referenceFeature)
        {
            return this.RetrieveUsageForCustomerRequest(referenceCustomer, referenceFeature).ExecuteAsync();
        }

        /// <summary>
        /// Get usage for a given subscription and feature
        /// </summary>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        public Usage RetrieveUsageForSubscription(long idSubscription, string referenceFeature)
        {
            return this.RetrieveUsageForSubscriptionRequest(idSubscription, referenceFeature).Execute();
        }

        /// <summary>
        /// Get usage for a given subscription and feature
        /// </summary>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <returns>The related usage</returns>
        public Task<Usage> RetrieveUsageForSubscriptionAsync(long idSubscription, string referenceFeature)
        {
            return this.RetrieveUsageForSubscriptionRequest(idSubscription, referenceFeature).ExecuteAsync();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="increment">the increment to apply to current usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Usage UpdateUsageByIncrement(string referenceCustomer, string referenceFeature, int increment, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByIncrementRequest(referenceCustomer, referenceFeature, increment, dateStamp, idSubscription).Execute();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="increment">the increment to apply to current usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Task<Usage> UpdateUsageByIncrementAsync(string referenceCustomer, string referenceFeature, int increment, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByIncrementRequest(referenceCustomer, referenceFeature, increment, dateStamp, idSubscription).ExecuteAsync();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="quantityCurrent">the new usage quantity</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Usage UpdateUsageByCurrentQuantity(string referenceCustomer, string referenceFeature, int quantityCurrent, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByCurrentQuantityRequest(referenceCustomer, referenceFeature, quantityCurrent, dateStamp, idSubscription).Execute();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="quantityCurrent">the new usage quantity</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Task<Usage> UpdateUsageByCurrentQuantityAsync(string referenceCustomer, string referenceFeature, int quantityCurrent, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByCurrentQuantityRequest(referenceCustomer, referenceFeature, quantityCurrent, dateStamp, idSubscription).ExecuteAsync();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="isEnabled">toggle usage on an on/off feature</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Usage UpdateUsageByActivation(string referenceCustomer, string referenceFeature, bool isEnabled, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByActivationRequest(referenceCustomer, referenceFeature, isEnabled, dateStamp, idSubscription).Execute();
        }

        /// <summary>
        /// Update usage for a given customer and feature
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of related feature</param>
        /// <param name="isEnabled">toggle usage on an on/off feature</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <returns>The related usage</returns>
        public Task<Usage> UpdateUsageByActivationAsync(string referenceCustomer, string referenceFeature, bool isEnabled, DateTime? dateStamp = null, long? idSubscription = null)
        {
            return this.UpdateUsageByActivationRequest(referenceCustomer, referenceFeature, isEnabled, dateStamp, idSubscription).ExecuteAsync();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="increment">the number of units to increment that usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Pricing EstimateUsageUpdateByIncrement(string referenceCustomer, string referenceFeature, int increment, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByIncrementRequest(referenceCustomer, referenceFeature, increment, idSubscription, dateStamp, html).Execute();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="increment">the number of units to increment that usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Task<Pricing> EstimateUsageUpdateByIncrementAsync(string referenceCustomer, string referenceFeature, int increment, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByIncrementRequest(referenceCustomer, referenceFeature, increment, idSubscription, dateStamp, html).ExecuteAsync();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="quantityCurrent">the new value of the usage (On-Off features only)</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Pricing EstimateUsageUpdateByCurrentQuantity(string referenceCustomer, string referenceFeature, int quantityCurrent, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByCurrentQuantityRequest(referenceCustomer, referenceFeature, quantityCurrent, idSubscription, dateStamp, html).Execute();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="quantityCurrent">the new value of the usage (On-Off features only)</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Task<Pricing> EstimateUsageUpdateByCurrentQuantityAsync(string referenceCustomer, string referenceFeature, int quantityCurrent, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByCurrentQuantityRequest(referenceCustomer, referenceFeature, quantityCurrent, idSubscription, dateStamp, html).ExecuteAsync();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="isEnabled">the new status of given on-off usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Pricing EstimateUsageUpdateByActivation(string referenceCustomer, string referenceFeature, bool isEnabled, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByActivationRequest(referenceCustomer, referenceFeature, isEnabled, idSubscription, dateStamp, html).Execute();
        }

        /// <summary>
        /// Estimate the exact price for an usage update
        /// </summary>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceFeature">reference of the related feature</param>
        /// <param name="idSubscription">reference of related subscription</param>
        /// <param name="isEnabled">the new status of given on-off usage</param>
        /// <param name="dateStamp">the date the usage update occurs, for concurrency issues. Defaults to now (UTC)</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Task<Pricing> EstimateUsageUpdateByActivationAsync(string referenceCustomer, string referenceFeature, bool isEnabled, long? idSubscription = null, DateTime? dateStamp = null, bool? html = true)
        {
            return this.EstimateUsageUpdateByActivationRequest(referenceCustomer, referenceFeature, isEnabled, idSubscription, dateStamp, html).ExecuteAsync();
        }

        /// <summary>
        /// Compute the exact price for given customer to subscribe to given offer
        /// If there is a trial, the pricing will contain the pricing for the first billing period and the pricing for the next term
        /// You can override the offer's parameters in case you need a customized subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Pricing EstimateSubscriptionUpgrade(string referenceCustomer, string referenceOffer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, bool? html = true)
        {
            return this.EstimateSubscriptionUpgradeRequest(referenceCustomer, referenceOffer, referenceCustomerBuyer, tryStart, dateStart, amountUpFront, amountTrial, unitTrial, durationTrial, amountRecurrence, unitRecurrence, durationRecurrence, countRecurrences, countMinRecurrences, amountTermination, html).Execute();
        }

        /// <summary>
        /// Compute the exact price for given customer to subscribe to given offer
        /// If there is a trial, the pricing will contain the pricing for the first billing period and the pricing for the next term
        /// You can override the offer's parameters in case you need a customized subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The corresponding pricing</returns>
        public Task<Pricing> EstimateSubscriptionUpgradeAsync(string referenceCustomer, string referenceOffer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, bool? html = true)
        {
            return this.EstimateSubscriptionUpgradeRequest(referenceCustomer, referenceOffer, referenceCustomerBuyer, tryStart, dateStart, amountUpFront, amountTrial, unitTrial, durationTrial, amountRecurrence, unitRecurrence, durationRecurrence, countRecurrences, countMinRecurrences, amountTermination, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve an offer
        /// </summary>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <returns>The related offer</returns>
        public Offer RetrieveOffer(string referenceOffer, string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? links = false)
        {
            return this.RetrieveOfferRequest(referenceOffer, referenceSegment, language, html, ignoreFeatures, links).Execute();
        }

        /// <summary>
        /// Retrieve an offer
        /// </summary>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <returns>The related offer</returns>
        public Task<Offer> RetrieveOfferAsync(string referenceOffer, string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? links = false)
        {
            return this.RetrieveOfferRequest(referenceOffer, referenceSegment, language, html, ignoreFeatures, links).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve an offer for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - ignored if ignoreFeatures has been specified. If true, returns only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related offer, with customer-specific 'subscribe' links to allow the customer to subscribe to the offer</returns>
        public Offer RetrieveOfferForCustomer(string referenceCustomer, string referenceOffer, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null)
        {
            return this.RetrieveOfferForCustomerRequest(referenceCustomer, referenceOffer, html, ignoreFeatures, isVisible).Execute();
        }

        /// <summary>
        /// Retrieve an offer for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - ignored if ignoreFeatures has been specified. If true, returns only visible features</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <returns>The related offer, with customer-specific 'subscribe' links to allow the customer to subscribe to the offer</returns>
        public Task<Offer> RetrieveOfferForCustomerAsync(string referenceCustomer, string referenceOffer, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null)
        {
            return this.RetrieveOfferForCustomerRequest(referenceCustomer, referenceOffer, html, ignoreFeatures, isVisible).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of offers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers</returns>
        public PaginatedList<Offer> RetrieveOffers(string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null, bool? links = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersRequest(referenceSegment, language, html, ignoreFeatures, isVisible, links, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of offers
        /// </summary>
        /// <param name="referenceSegment">the related segment. If not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="language">language of the localized texts</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="links">true to prevent returning related links (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers</returns>
        public Task<PaginatedList<Offer>> RetrieveOffersAsync(string referenceSegment = null, string language = null, bool? html = true, bool? ignoreFeatures = false, bool? isVisible = null, bool? links = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersRequest(referenceSegment, language, html, ignoreFeatures, isVisible, links, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of offers for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'subscribe' links to allow the customer to subscribe to each offer</returns>
        public PaginatedList<Offer> RetrieveOffersForCustomer(string referenceCustomer, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersForCustomerRequest(referenceCustomer, html, isVisible, ignoreFeatures, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of offers for a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'subscribe' links to allow the customer to subscribe to each offer</returns>
        public Task<PaginatedList<Offer>> RetrieveOffersForCustomerAsync(string referenceCustomer, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersForCustomerRequest(referenceCustomer, html, isVisible, ignoreFeatures, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve an offer to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <returns>The related offer, with customer-specific 'upgrade' links to allow the customer to subscribe to the offer</returns>
        public Offer RetrieveOfferToUpgradeCustomer(string referenceCustomer, string referenceOffer, long? idSubscription = null, bool? html = true, bool? ignoreFeatures = false)
        {
            return this.RetrieveOfferToUpgradeCustomerRequest(referenceCustomer, referenceOffer, idSubscription, html, ignoreFeatures).Execute();
        }

        /// <summary>
        /// Retrieve an offer to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="referenceOffer">reference of requested offer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <returns>The related offer, with customer-specific 'upgrade' links to allow the customer to subscribe to the offer</returns>
        public Task<Offer> RetrieveOfferToUpgradeCustomerAsync(string referenceCustomer, string referenceOffer, long? idSubscription = null, bool? html = true, bool? ignoreFeatures = false)
        {
            return this.RetrieveOfferToUpgradeCustomerRequest(referenceCustomer, referenceOffer, idSubscription, html, ignoreFeatures).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of offers to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'upgrade' links to allow the customer to subscribe to each offer</returns>
        public PaginatedList<Offer> RetrieveOffersToUpgradeCustomer(string referenceCustomer, long? idSubscription = null, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersToUpgradeCustomerRequest(referenceCustomer, idSubscription, html, isVisible, ignoreFeatures, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of offers to upgrade the subscription of a given customer
        /// </summary>
        /// <param name="referenceCustomer">reference of the customer</param>
        /// <param name="idSubscription">the id of the subscription to upgrade</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text</param>
        /// <param name="isVisible">filter - If true, returns only visible offers (with their visible features if 'ignoreFeatures' is true). If false, returns only hidden offers</param>
        /// <param name="ignoreFeatures">true to prevent returning contained features (for faster call)</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The related offers, with customer-specific 'upgrade' links to allow the customer to subscribe to each offer</returns>
        public Task<PaginatedList<Offer>> RetrieveOffersToUpgradeCustomerAsync(string referenceCustomer, long? idSubscription = null, bool? html = true, bool? isVisible = null, bool? ignoreFeatures = false, int? page = null, int? sizePage = null)
        {
            return this.RetrieveOffersToUpgradeCustomerRequest(referenceCustomer, idSubscription, html, isVisible, ignoreFeatures, page, sizePage).ExecuteAsync();
        }

        /// <summary>
        /// Create (and start) a subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">(mandatory) reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="titleLocalized">Offer override - localized title</param>
        /// <param name="descriptionLocalized">Offer override - localized description</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription CreateSubscription(string referenceOffer, string referenceCustomer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, string titleLocalized = null, string descriptionLocalized = null, bool? html = null)
        {
            return this.CreateSubscriptionRequest(referenceOffer, referenceCustomer, referenceCustomerBuyer, tryStart, dateStart, amountUpFront, amountTrial, unitTrial, durationTrial, amountRecurrence, unitRecurrence, durationRecurrence, countRecurrences, countMinRecurrences, amountTermination, titleLocalized, descriptionLocalized, html).Execute();
        }

        /// <summary>
        /// Create (and start) a subscription
        /// </summary>
        /// <param name="referenceOffer">reference of the related offer, required if idOffer is null</param>
        /// <param name="referenceCustomer">(mandatory) reference of related customer</param>
        /// <param name="referenceCustomerBuyer">reference of related buyer, if the buyer is not the recipient of the subscription</param>
        /// <param name="tryStart">if true, will check if the customer is billable. if he's not then an error is returned</param>
        /// <param name="dateStart">specify the subscription's start date</param>
        /// <param name="amountUpFront">Offer override - upfront amount </param>
        /// <param name="amountTrial">Offer override - trial period amount</param>
        /// <param name="unitTrial">Offer override - trial period duration unit</param>
        /// <param name="durationTrial">Offer override - trial period duration</param>
        /// <param name="amountRecurrence">Offer override - recurrence amount</param>
        /// <param name="unitRecurrence">Offer override - recurrence period unit</param>
        /// <param name="durationRecurrence">Offer override - recurrence period duration</param>
        /// <param name="countRecurrences">Offer override - number of billing periods (1 or more, null for infinite)</param>
        /// <param name="countMinRecurrences">Offer override - minimum number of billing periods (engagement)</param>
        /// <param name="amountTermination">Offer override - termination fee</param>
        /// <param name="titleLocalized">Offer override - localized title</param>
        /// <param name="descriptionLocalized">Offer override - localized description</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> CreateSubscriptionAsync(string referenceOffer, string referenceCustomer, string referenceCustomerBuyer = null, bool? tryStart = null, DateTime? dateStart = null, int? amountUpFront = null, int? amountTrial = null, TimeUnit? unitTrial = null, int? durationTrial = null, int? amountRecurrence = null, TimeUnit? unitRecurrence = null, int? durationRecurrence = null, int? countRecurrences = null, int? countMinRecurrences = null, int? amountTermination = null, string titleLocalized = null, string descriptionLocalized = null, bool? html = null)
        {
            return this.CreateSubscriptionRequest(referenceOffer, referenceCustomer, referenceCustomerBuyer, tryStart, dateStart, amountUpFront, amountTrial, unitTrial, durationTrial, amountRecurrence, unitRecurrence, durationRecurrence, countRecurrences, countMinRecurrences, amountTermination, titleLocalized, descriptionLocalized, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription RetrieveSubscription(long idSubscription, bool? html = null)
        {
            return this.RetrieveSubscriptionRequest(idSubscription, html).Execute();
        }

        /// <summary>
        /// Retrieve a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> RetrieveSubscriptionAsync(long idSubscription, bool? html = null)
        {
            return this.RetrieveSubscriptionRequest(idSubscription, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a running subscription for a customer.
        ///
        /// Throws an error if the customer has multiple running subscriptions.
        /// </summary>
        /// <param name="referenceCustomer">Customer whose subscription is requested. </param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription RetrieveSubscriptionForCustomer(string referenceCustomer, bool? html = null)
        {
            return this.RetrieveSubscriptionForCustomerRequest(referenceCustomer, html).Execute();
        }

        /// <summary>
        /// Retrieve a running subscription for a customer.
        ///
        /// Throws an error if the customer has multiple running subscriptions.
        /// </summary>
        /// <param name="referenceCustomer">Customer whose subscription is requested. </param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> RetrieveSubscriptionForCustomerAsync(string referenceCustomer, bool? html = null)
        {
            return this.RetrieveSubscriptionForCustomerRequest(referenceCustomer, html).ExecuteAsync();
        }

        /// <summary>
        /// Suspend a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="subscriptionState">The subscription suspension status.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription SuspendSubscription(long idSubscription, SubscriptionState subscriptionState = SubscriptionState.SuspendedAgent, bool? html = null)
        {
            return this.SuspendSubscriptionRequest(idSubscription, subscriptionState, html).Execute();
        }

        /// <summary>
        /// Suspend a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="subscriptionState">The subscription suspension status.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> SuspendSubscriptionAsync(long idSubscription, SubscriptionState subscriptionState = SubscriptionState.SuspendedAgent, bool? html = null)
        {
            return this.SuspendSubscriptionRequest(idSubscription, subscriptionState, html).ExecuteAsync();
        }

        /// <summary>
        /// Start or restart a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription StartSubscription(long idSubscription, bool? html = null)
        {
            return this.StartSubscriptionRequest(idSubscription, html).Execute();
        }

        /// <summary>
        /// Start or restart a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> StartSubscriptionAsync(long idSubscription, bool? html = null)
        {
            return this.StartSubscriptionRequest(idSubscription, html).ExecuteAsync();
        }

        /// <summary>
        /// Terminate a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="immediate">true to terminate the subscription immediately, false to terminate at the end of the billign period.</param>
        /// <param name="dateTermination">ignored if immediate is true. Date of termination, if you need to specify a date that is not the end of the billing period.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription TerminateSubscription(long idSubscription, bool immediate = false, DateTime? dateTermination = null, bool? html = null)
        {
            return this.TerminateSubscriptionRequest(idSubscription, immediate, dateTermination, html).Execute();
        }

        /// <summary>
        /// Terminate a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="immediate">true to terminate the subscription immediately, false to terminate at the end of the billign period.</param>
        /// <param name="dateTermination">ignored if immediate is true. Date of termination, if you need to specify a date that is not the end of the billing period.</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> TerminateSubscriptionAsync(long idSubscription, bool immediate = false, DateTime? dateTermination = null, bool? html = null)
        {
            return this.TerminateSubscriptionRequest(idSubscription, immediate, dateTermination, html).ExecuteAsync();
        }

        /// <summary>
        /// Upgrade a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="referenceOffer">reference of the related offer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription UpgradeSubscription(long idSubscription, string referenceOffer, bool? html = null)
        {
            return this.UpgradeSubscriptionRequest(idSubscription, referenceOffer, html).Execute();
        }

        /// <summary>
        /// Upgrade a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="referenceOffer">reference of the related offer</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> UpgradeSubscriptionAsync(long idSubscription, string referenceOffer, bool? html = null)
        {
            return this.UpgradeSubscriptionRequest(idSubscription, referenceOffer, html).ExecuteAsync();
        }

        /// <summary>
        /// Change the renewal date of a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="dateRenewal">the updated renewal date. Must be in the future</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public DetailedSubscription UpdateSubscriptionRenewalDate(long idSubscription, DateTime dateRenewal, bool? html = null)
        {
            return this.UpdateSubscriptionRenewalDateRequest(idSubscription, dateRenewal, html).Execute();
        }

        /// <summary>
        /// Change the renewal date of a subscription
        /// </summary>
        /// <param name="idSubscription">id of the requested subscription</param>
        /// <param name="dateRenewal">the updated renewal date. Must be in the future</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <returns>The related subscription</returns>
        public Task<DetailedSubscription> UpdateSubscriptionRenewalDateAsync(long idSubscription, DateTime dateRenewal, bool? html = null)
        {
            return this.UpdateSubscriptionRenewalDateRequest(idSubscription, dateRenewal, html).ExecuteAsync();
        }

        /// <summary>
        /// Retrieve a list of subscriptions
        /// </summary>
        /// <param name="referenceCustomer">Filter - returns only subscription where given customer is the recipient</param>
        /// <param name="referenceCustomerBuyer">Filter - returns only subscription where given customer is the buyer</param>
        /// <param name="referenceSegment">the related segment, if not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The list of subscriptions</returns>
        public PaginatedList<Subscription> ListSubscriptions(string referenceCustomer = null, string referenceCustomerBuyer = null, string referenceSegment = null, bool? html = null, int? page = null, int? sizePage = null)
        {
            return this.ListSubscriptionsRequest(referenceCustomer, referenceCustomerBuyer, referenceSegment, html, page, sizePage).Execute();
        }

        /// <summary>
        /// Retrieve a list of subscriptions
        /// </summary>
        /// <param name="referenceCustomer">Filter - returns only subscription where given customer is the recipient</param>
        /// <param name="referenceCustomerBuyer">Filter - returns only subscription where given customer is the buyer</param>
        /// <param name="referenceSegment">the related segment, if not provided and you have multiple segments, defaults on the first segment</param>
        /// <param name="html">true to have the localized text as HTML string, false for plain text. Default is true</param>
        /// <param name="page">Pagination : page index (starts from 1) </param>
        /// <param name="sizePage">Pagination : page size (default is 10) </param>
        /// <returns>The list of subscriptions</returns>
        public Task<PaginatedList<Subscription>> ListSubscriptionsAsync(string referenceCustomer = null, string referenceCustomerBuyer = null, string referenceSegment = null, bool? html = null, int? page = null, int? sizePage = null)
        {
            return this.ListSubscriptionsRequest(referenceCustomer, referenceCustomerBuyer, referenceSegment, html, page, sizePage).ExecuteAsync();
        }

 
    }
}

