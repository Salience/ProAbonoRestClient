<#@ template debug="true" hostSpecific="true" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #> 
<#   
    var sourceFile = "ProAbonoClientRequests.cs";
    var targetNamespace = "ProAbono";
    var targetClass = "ProAbonoClient";
    var targetInterfaceSync = "IProAbonoClient";
    var targetInterfaceAsync = "IAsyncProAbonoClient";

////////////////////////////////////////////////////////////////////////

    // load requests file
    var sourceFilePath = this.Host.ResolvePath(sourceFile);
    var sourceFileLines = File.ReadAllLines(sourceFilePath);

    var parsingRegex = new Regex(@"^private\s+IExecutableRequest(<(?<returnType>[\w\<\>]*)>)?\s+(?<name>\w+)Request\((?<args>[^\)]+)\)$");

    // parse requests file content
    var commentLines = new List<string>();
    var matches = new List<MatchAndComments>();

    for(int i = 0; i < sourceFileLines.Length; i++)
    {
        var line = sourceFileLines[i].Trim();
        if(string.IsNullOrEmpty(line))
            continue;

        if(line.StartsWith("///"))
        {
            commentLines.Add(line);
            continue;
        }

        if(!line.StartsWith("private IExecutableRequest"))
        {
            commentLines.Clear();
            continue;
        }

        while(!line.EndsWith(")") && i < sourceFileLines.Length - 1)
            line += " " + sourceFileLines[++i].Trim();

        var match = parsingRegex.Match(line);
        if(!match.Success)
        {
            commentLines.Clear();
            continue;
        }
            
        matches.Add(new MatchAndComments{
            Match = match, 
            CommentLines = commentLines
        });

        commentLines = new List<string>();
    }

    var methods = matches
        .Select(m => new
        {
            ReturnType = m.Match.Groups["returnType"].Value,
            Name = m.Match.Groups["name"].Value,
            AllArgs = m.Match.Groups["args"].Value,
            CommentLines = m.CommentLines
        })
        .Select(m => new MethodData
        {
            ReturnType = string.IsNullOrEmpty(m.ReturnType) ? "void" : m.ReturnType,
            Name = m.Name,
            AllArgs = m.AllArgs,
            ArgNames = m.AllArgs.Split(',')
                .Select(a => a.Trim().Split(' ')[1]).ToArray(),
            CommentLines = m.CommentLines
        })
        .ToArray();
#>
////////////////////////////////////////////////////////////////////
//                         AUTO-GENERATED                         //
////////////////////////////////////////////////////////////////////
//                                                                //
// This file was generated by a tool. Do not modify it directly.  //
// Instead, modify the source file ProAbonoClientRequests.cs.     //
//                                                                //
// Last generation: <#= DateTime.Now.ToString("dd/MM/yyyy HH:mm") #>                              //
//                                                                //
////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace <#= targetNamespace #>
{
    public interface <#= targetInterfaceSync #>
    {
        <#= targetInterfaceAsync #> Async { get; }

<#
foreach(var method in methods) 
{
    WriteMethodDeclaration(method, false);
}
#> 
    }

    public interface <#= targetInterfaceAsync #>
    {
        <#= targetInterfaceSync #> Sync { get; }

<#
foreach(var method in methods)
{
    WriteMethodDeclaration(method, true);
}
#> 
    }

    public partial class <#= targetClass #> : <#= targetInterfaceSync #>, <#= targetInterfaceAsync #>
    {
        <#= targetInterfaceAsync #> <#= targetInterfaceSync #>.Async => this;
        <#= targetInterfaceSync #> <#= targetInterfaceAsync #>.Sync => this;

<#
foreach(var method in methods)
{
    WriteMethodBody(method, false);
    WriteMethodBody(method, true);
}
#> 
    }
}

<#+
////////////////////////////////////////////////////////////////////////

void WriteComments(MethodData method)
{
    foreach(var commentLine in method.CommentLines)
    {
#>
        <#= commentLine #>
<#+
    }
}

void WriteMethodDeclaration(MethodData method, bool isAsync)
{
    WriteComments(method);

    var asyncSuffix = isAsync ? "Async" : "";
    var fullReturnType = isAsync ? (method.ReturnType == "void" ? "Task" : "Task<" + method.ReturnType + ">") : method.ReturnType;
#>
        <#= fullReturnType #> <#= method.Name #><#= asyncSuffix #>(<#= method.AllArgs #>);

<#+
}

void WriteMethodBody(MethodData method, bool isAsync)
{
    WriteComments(method);

    var asyncSuffix = isAsync ? "Async" : "";
    var fullReturnType = isAsync ? (method.ReturnType == "void" ? "Task" : "Task<" + method.ReturnType + ">") : method.ReturnType;
#>
        public <#= fullReturnType #> <#= method.Name #><#= asyncSuffix #>(<#= method.AllArgs #>)
        {
            <#= fullReturnType == "void" ? "" : "return " #>this.<#= method.Name #>Request(<#= string.Join(", ", method.ArgNames) #>).Execute<#= asyncSuffix #>();
        }

<#+
}

////////////////////////////////////////////////////////////////////////

class MatchAndComments
{
    public Match Match { get; set; }
    public List<string> CommentLines { get; set; }
}

class MethodData
{
    public string ReturnType { get; set; }
    public string Name { get; set; }
    public string AllArgs { get; set; }
    public string[] ArgNames { get; set; }
    public List<string> CommentLines { get; set; }
}
#>